# OOP Design Patterns in Java

Welcome to the **OOP Design Patterns in Java** 
This project demonstrates various object-oriented design patterns using Java. Whether you’re a beginner or an experienced developer, these patterns will help you write cleaner, more maintainable, and scalable code.

## 🎥 YouTube Playlist
To complement this repository, I also have a YouTube Playlist where each design pattern is explained with code examples.

🎬 Watch the playlist here: [OOP Design Patterns in Java - YouTube Playlist](https://www.youtube.com/playlist?list=PL0Kgfsu1RnhKvI65E7VRvcyKgXqc6WMrh)

Make sure to subscribe to the channel for regular updates on design patterns and Java development tips!

## 📖 What are Design Patterns?

Design patterns are proven solutions to common software design problems. They represent best practices that software developers can follow to solve recurring issues in object-oriented design. Each pattern describes a problem, a solution, and the consequences of the solution.

## 🔍 Why Design Patterns?

Design patterns help developers:
- **Improve code reusability**: They provide generalized solutions that can be applied in various situations.
- **Maintainable code**: With clear patterns, code becomes easier to understand and modify.
- **Scalable applications**: Patterns often promote loose coupling and high cohesion, making code easier to extend.

## 🏗️ Types of Design Patterns Covered

This repository covers the following categories of design patterns in Java:

### 1. **Creational Patterns**
   - **Singleton**: Ensures a class has only one instance and provides a global point of access to it.
   - **Factory Method**: Defines an interface for creating an object but lets subclasses alter the type of objects that will be created.
   - **Builder**: Simplifies object construction by allowing incremental and controlled construction of complex objects.
   - **Prototype**: Enables object cloning, creating new instances by copying an existing object.

### 2. **Structural Patterns**
   - **Adapter**: Allows incompatible interfaces to work together by providing a wrapper class.
   - **Composite**: Lets you compose objects into tree-like structures to represent part-whole hierarchies.
   - **Decorator**: Dynamically adds or overrides behavior in an object.
   - **Facade**: Provides a simplified interface to a more complex system.

### 3. **Behavioral Patterns**
   - **Observer**: Allows a subject to notify its observers of any changes without the need to tightly couple them.
   - **Strategy**: Enables selecting an algorithm's behavior at runtime by encapsulating algorithms in separate classes.
   - **Command**: Encapsulates a request as an object, thus allowing parameterization of methods with different requests.

## 📂 Project Structure

Here is a brief overview of the repository structure:

```plaintext
├── src/main/java/com/learnthencode/designpattern/
│   ├── creational/
│   ├── structural/
│   ├── behavioral/
|   Main.java
├── README.md
├── build.gradle
├── settings.gradle
```

- Each design pattern is implemented in its respective category folder (`creational/`, `structural/`, `behavioral/`).
- Each pattern has its own set of classes with clear comments and documentation.

## 📚 Resources

- **[Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)** by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides.
- **Head First Design Patterns** by Eric Freeman and Elisabeth Robson.
- Official [Java Documentation](https://docs.oracle.com/en/java/).
